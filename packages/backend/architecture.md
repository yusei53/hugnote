# バックエンド アーキテクチャ構成

## ディレクトリ構成

```
/src
├── index.ts                # エントリーポイント・ルーティング
├── controllers/            # コントローラー層（クラスベース）
│   └── userController.ts
├── usecase/                # ユースケース層（クラスベース）
│   ├── request/
│   │   └── userRequest.ts  # リクエストDTO・バリデーション
│   ├── response/
│   │   └── userResponse.ts # レスポンスDTO
│   └── userUsecase.ts      # ユースケース本体
├── repositories/           # リポジトリ層（クラスベース）
│   └── userRepository.ts
├── entities/               # エンティティ・型定義
│   └── user.ts
├── config/
│   └── container.ts        # DIコンテナ（依存性注入）
```

## 各層の役割

- **controllers/**
  - HTTPリクエストを受け取り、バリデーション・ユースケース呼び出し・レスポンス返却を担当
  - クラスベースで実装し、ユースケースをコンストラクタで受け取る（DI）

- **usecase/**
  - アプリケーション固有のビジネスロジックを記述
  - クラスベースで実装し、リポジトリなどをコンストラクタで受け取る（DI）
  - request/response配下でDTOやバリデーションを管理

- **repositories/**
  - DBや外部APIとのやりとりを担当
  - クラスベースで実装

- **entities/**
  - ドメインエンティティや型定義

- **config/container.ts**
  - 各クラスのインスタンス生成と依存解決を一元管理
  - ルーティングでコントローラを利用する際は、ここからインスタンスをimport

## DI（依存性注入）について

- 各層はコンストラクタインジェクションで依存を受け取る
- テスト時は依存クラスをモックに差し替えることで、柔軟な単体テストが可能
- interfaceは利用せず、クラスベースのみで実装しているが、十分にテスト容易性・拡張性を確保

## テスト容易性

- 依存を差し替えられるため、Jest等でモックを渡してユースケースやコントローラの単体テストが容易
- interfaceを使わなくても、クラスのメソッドをオーバーライドしたり、jest.fn()で差し替え可能

---
